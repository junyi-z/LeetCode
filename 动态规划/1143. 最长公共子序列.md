## 1143. 最长公共子序列

1. 我们需要一个办法储存计算过程中的最大值，

2. 使用动态规划的时候，需要明确一个状态转移方程，
	若，当前指针指向的字符串A和字符串B中的字符相等时，则，最大长度等于上一次的长度加1；
	若，当前指针指向的字符串A和字符串B中的字符不相等时，则选择回退字符串A一格，和，回退字符串B一格的，两种情况下，取最大值，
	
3. 不相等的情况下，说明A和B，选取的字符，至少有一个不会出现在最长公共子序列中，但是我们并不知道是哪个不在，所以需要对比，

4. ```java
      int len1 = text1.length();
           int len2 = text2.length();
   
           if (len1 == 0 || len2 == 0){
               return 0;
           }
   
           int[][] dp = new int[len1+1][len2+1];
           // dp[i][j] 表示 S1 的前 i 个字符与 S2 的前 j 个字符最长公共子序列的长度
           // s1(i) 和 s2(j) 相等的时候， 意味着 S1 的前 i 个字符与 S2 的前 j 个字符最长公共子序列的长度 可以加1了， 子序列多了一位数，
           // 不相等的时候， 意味着dp[i][j] 相对于dp[i-1][j-1]，在s1中增加了一个字符的情况下 或者在s2中增加了一个字符的情况下，
           // S1 的前 i-1 个字符与 S2 的前 j 个字符 或 
           // S1 的前 i 个字符与 S2 的前 j-1 个字符最长公共子序列 
           // 两种情况下取一个最大值，来赋值给dp[i][j]
           // 不等的情况下的选择核心是： dp[i][j] 表示 S1 中前 i 个字符与 S2 中前 j 个字符的最长公共子序列长度，不一定包含 S1i 和 S2j
           // 所以当多了一个字符的时候，可能与其中的一个字符发生一次匹配
           dp[0][0] = 0;
   
           for (int i = 1; i <= len1; ++i){
               for(int j = 1; j <= len2; ++j){
                   if(text1.charAt(i-1) == text2.charAt(j-1)){
                       dp[i][j] = dp[i-1][j-1] + 1;
                   }
                   else{
                       dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
                   }
               }
   
           }
           return dp[len1][len2];
   ```

   