## 201. 数字范围按位与

1. 按位与，就是，只有都是1，才能得到1，否则就是0，因此求这一些数字的按位与，就是“求所有对应二进制字符串的公共前缀，再用0补上后面的剩余位”
2. 假设对于所有这些二进制串，前 ii 位均相同，第 i+1i+1 位开始不同，由于 [m,n][m,n] 连续，所以第 i+1i+1 位在 [m,n][m,n] 的数字范围从小到大列举出来一定是前面全部是 00，后面全部是 11，在上图中对应 [9,11][9,11] 均为 00，[12,12][12,12] 均为 11。并且一定存在连续的两个数 xx 和 x+1x+1，满足 xx 的第 i+1i+1 位为 00，后面全为 11，x+1x+1 的第 i+1i+1 位为 11，后面全为 00，对应上图中的例子即为 1111 和 1212。这种形如 0111 \ldots0111… 和 1000 \ldots1000… 的二进制串的按位与的结果一定为 0000 \ldots0000…，因此第 i+1i+1 位开始的剩余位均为 00，前 ii 位由于均相同，因此按位与结果不变。最后的答案即为二进制字符串的公共前缀再用零补上后面的剩余位。
3. 公共前缀后的数字位，一定是存在0的，所以必按位与为0，
4. ![公共前缀](https://assets.leetcode-cn.com/solution-static/201/2.png)
5. 因此只要保留到为1的结果，把回退到原来的位置，即可，这些1对应的十进制数就是答案
6. 时间复杂度：O(logn),算法复杂度取决于m和n的二进制位数，n不会比m小，所以就是取决n，空间复杂度1，

```java
class Solution {
    public int rangeBitwiseAnd(int m, int n) {
        int shift = 0;
        while (m < n){
            m = m >> 1;
            n = n >> 1;
            shift++;
        }
        return m << shift;
    }
}
```

