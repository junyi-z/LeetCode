## 406. 根据身高重建队列

1. 核心代码1：
  `        Arrays.sort(people, new Comparator<int[]>(){
           @Override
           public int compare(int[] a, int [] b){
               return a[0] == b[0]? a[1] - b[1] : b[0] - a[0];
           }
       });`
  重写比较器，如果两个数组的第一位相同，说明他们身高相同，那么就按第二位升序排序，因为他表示排在这个人前面且身高大于或等于他身高的人数
  如果两个数组第一位不同，则按第一位降序排序，也就是将身高最高的人防止队列最前面。

2. 核心思想：先将身高最高的人排序，再将矮的排序，因为矮的人无论怎么排，都不会影响身高较高的人的相对顺序，因为k是排在这个人前面且身高大于或等于h的人数。排好高个的人只需要再将矮个的人插入即可。

3. 核心代码2：
	`for(int[] p : people){
            output.add(p[1], p);
        }`
				在对二维数组排序以后，根据每个数组中的k值来进行插入，由于是按照身高从高到低插入，在k值相同的情况下，插入矮个的人可以直接占据原来高个人的位置，且不影响高个的k值，因为k值只被比自己高或者一样高的人影响。比如：【7，0】占据链表的0位后，插入【5，0】，5被插入到链表0的位置，7向后一位，但是7的0依旧有效。
	
4. 核心代码3：`return output.toArray(new int[n][2]);` 将一维数组组成的链表转化成二维链表的api，记住!!!!

5. ```java
   class Solution {
       public int[][] reconstructQueue(int[][] people) {
           Arrays.sort(people, new Comparator<int[]>(){
               @Override
               public int compare(int[] a, int [] b){
                   return a[0] == b[0]? a[1] - b[1] : b[0] - a[0];
               }
           });
   
           LinkedList<int[]> output = new LinkedList<int[]>();
   
           for(int[] p : people){
               output.add(p[1], p);
           }
           int n = people.length;
           return output.toArray(new int[n][2]);
       }
   
   }
   ```

   

别人的解释：

对官方答案做一个小解析： 思路：

先按身高降序排序，相同身高按k升序排序，经过此次排序后高的人一定在矮的人的前面并且相同高度的人的相对顺序就是最终结果的相对顺序。请记住这两点，敲黑板

创建一个集合，这个集合的每个元素是一个一维数组，也就是我们二维数组的一行。

以行为单位遍历排好序的people[][]数组，假设每行数据是p[], 把每行元素插入到集合的索引为p[1]的位置，

把集合中的数据转换为一个二维数组，返回即是正确结果

下面解释为什么经过第三步后就达到了我们题目要求的输出结果：

经过第一步排序后高的人一定在矮的人的前面并且相同高度的人的相对顺序就是最终结果的相对顺序，所以 在进行第三步的过程中，高的人的数据肯定是先被存入集合的，所以每当我们取出一行数据，集合中已有的元素的身高肯定都是大于等于当前元素的身高的，所以当我们取出p[]数组后，发现前面应该有p[1]个人比自己高或者高度和自己相同，那么当前元素就应该排在集合的p[1]下标的位置(仔细想想是不是)，好比说目前有一个队列的人，这些人要么比你高，要么和你一样高，现在要你插入入队中，保证你前面有p[1]个人的身高大于等于你，你是不是应该排在索引为p[1]的位置